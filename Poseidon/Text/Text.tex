\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath} % Required for some math elements
\usepackage{amsfonts}
\usepackage{amsthm} % for proof pkg
\usepackage{amssymb}
\usepackage{verbatim}
\usepackage{hyperref}
\usepackage{comment}
\usepackage{color}
\usepackage{parskip} % Remove paragraph indentation
\usepackage[margin=1in]{geometry}
\usepackage[inline]{enumitem}
\usepackage{mathtools}
\usepackage{multirow}
\usepackage{listings}

\usepackage{color}
\definecolor{keywordcolor}{rgb}{0.7, 0.1, 0.1}   % red
\definecolor{tacticcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{sortcolor}{rgb}{0.1, 0.5, 0.1}      % green
\definecolor{attributecolor}{rgb}{0.7, 0.1, 0.1} % red

\def\lstlanguagefiles{lstlean.tex}
% set default language
\lstset{language=lean}

\newtheorem{lemma}{Lemma}
\newtheorem{claim}{Claim}
\newtheorem{theorem}{Theorem}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{fact}{Fact}[section]
\theoremstyle{remark}
\newtheorem*{remark}{Remark}

\newcommand{\anote}[1]{{\color{magenta} [AM: #1]}}
\newcommand{\Gen}{\mathsf{Gen}}
\newcommand{\Enc}{\mathsf{Enc}}
\newcommand{\Dec}{\mathsf{Dec}}
\newcommand{\pk}{\mathit{pk}}
\newcommand{\sk}{\mathit{sk}}
\newcommand{\bbZ}{\mathbb{Z}}
\newcommand{\bit}{\{0,1\}}
\newcommand{\la}{\leftarrow}
\newcommand{\ninN}{{n \in \mathbf{N}}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cG}{\mathcal{G}}
\newcommand{\RF}{\mathsf{RF}}
\newcommand{\Half}{\frac{1}{2}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\Adv}{\mathcal{A}}
\newcommand{\Ext}{\mathcal{E}}

\newcommand{\ignore}[1]{{}}

\newcommand{\samples}{\overset{\$}{\leftarrow}}
\newcommand{\hash}{\ensuremath{\mathcal{H}}}
\newcommand{\doubleplus}{+\kern-1.3ex+\kern0.8ex}
\newcommand{\mdoubleplus}{\ensuremath{\mathbin{+\mkern-10mu+}}}

\title{The Poseidon Hash Function formalisation in Lean 4}
\author{Ashvni Narayanan and Daniel Rogozin, for Yatima Inc}
\date{\today\footnote{The Lean 3 formalisation is by Ashvni Narayanan. Daniel Rogozin prepared the Lean 4 version and its text description.}}

\begin{document}

\maketitle

\section{Introduction}

In this document, we describe the Poseidon formalisation in Lean 4.
Initially, Poseidon has been introduced as a family of hash functions based on the permutations $\text{\emph{Poseidon}}^{\pi}$, see~\cite{grassi2021poseidon}.
This approach utilises the Hades strategy~\cite{grassi2020generalization} according to which (TODO: explain the Hades strategy with a couple of sentences).

\section{Formalisation itself}

We need some preliminaries first. Let $p, t$ be natural numbers and $p$ is prime. 
As usual, $\mathbb{Z}_p$ stands for prime field of order $p$. 
In the original text, it is also assumed that $\lceil \log_2(p) \rceil = n$ for some $n > 0$.

We introduce these requirements in Lean 4 by declaring the following variables.

\begin{lstlisting}
variable (p t : ℕ) [Fact p.Prime] [Field (Zmod p)] [Fintype (Finₓ t)]
\end{lstlisting}

\begin{lstlisting}
def ARC (c a : Finₓ t → Zmod p) (i : Finₓ t) : Zmod p := (a i) + (c i)
\end{lstlisting}

\begin{lstlisting}
def R_f_round (S_box' : Zmod p → Zmod p) (c : Finₓ t → Zmod p)
  (MDS' : Matrix (Finₓ t) (Finₓ t) (Zmod p)) (a : Finₓ t → Zmod p) : Finₓ t → Zmod p :=
  Matrix.mulVecₓ MDS' (λ i => S_box' (ARC p t c a i))
\end{lstlisting}

\begin{lstlisting}
    def R_p_round (S_box' : Zmod p → Zmod p) (c : Finₓ t → Zmod p)
    (MDS' : Matrix (Finₓ t) (Finₓ t) (Zmod p)) (a : Finₓ t → Zmod p) : Finₓ t → Zmod p :=
    Matrix.mulVecₓ MDS' 
      (λ i => dite ((i : ℕ) = 0) (λ _ => S_box' (ARC p t c a i)) (λ _ => ARC p t c a i))
\end{lstlisting}

\begin{lstlisting}
def P_perm (R_f R_p : ℕ) (S_box' : Zmod p → Zmod p) (c a : Finₓ t → Zmod p)
  (MDS' : Matrix (Finₓ t) (Finₓ t) (Zmod p)) : Finₓ t → Zmod p :=
  (R_f_round p t S_box' c MDS')^[R_f] ((R_p_round p t S_box' c MDS')^[R_p]
  ((R_f_round p t S_box' c MDS')^[R_f] a))
\end{lstlisting}

\begin{lstlisting}
def add_to_state (r cap : ℕ) (m : Finₓ r → Zmod p) 
  (a : Finₓ t → Zmod p) (h : t = r + cap) : Finₓ t → Zmod p :=
  λ i => dite ((i : ℕ) < r) (λ h => a i + m (Finₓ.castLt i h)) (λ h => a i)
\end{lstlisting}

\begin{lstlisting}
def P_hash (R_f R_p r o cap : ℕ) (hr : 1 ≤ r) (S_box' : Zmod p → Zmod p) 
  (c : Finₓ (r + cap) → Zmod p)
  (MDS' : Matrix (Finₓ (r + cap)) (Finₓ (r + cap)) (Zmod p)) (ho : o ≤ r + cap)
  (k : ℕ) (a : Finₓ (k * r + (r + cap)) → Zmod p) : Finₓ o → Zmod p
\end{lstlisting}

\bibliographystyle{unsrt}
\bibliography{refs}

\end{document}